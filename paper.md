# Игра в угадайку на haskell

Как и многие, я вижу особую радость в том, когда один и тот же принцип работает в разных, казалось бы, несхожих вещах.

Давайте напишем игру. Простую, как hello world. Игра называется "Угадай число".

Играют двое.
Первый загадывает число от 1 до 100.
Второй предлагает отгадку.
Если второй не угадал, первый сообщает второму, меньше его число или больше, чем загаданное.

Хотя я обещал в заголовке статьи, что писать мы будем на haskell, эту простейшую игру мы напишем на python. Каждый язык хорош по своему, и haskell, с его суровой типизацией, поможет нам в итоговой доводке идеи, о которой пойдет далее речь. А прототипировать можно и на питоне.

В простейшем случае, игра выглядит как-то так

    def guess_the_number(a,b):
        if a == b:
            print(f'Это точно {a}.')
            return a
        x = a + (b-a)//2
        res = input(f'Это {x}? ')
        if res == '>':
            return guess_the_number(x,b)
        if res == '<':
            return guess_the_number(a,x)
        if res == '=':
            return x
        else:
            print(
                '> если больше, = если равно, < если меньше \
                Попробуйте ещё раз'
            )
            return guess_the_number(a,b)
           


    if __name__ == '__main__':
        min_num = 1
        max_num = 100
        print(
            f'Игра "Угадай число"! \n\
            \nЗагадайте число от {min_num} до {max_num}, а я попробую угадать \
            \nВводите > если больше, = если равно, < если меньше\n'
        )
        x = guess_the_number(min_num, max_num)
        print(f'Ура, я угадал {x}!')

Представленная реализация игры самая простая и самая совершенная - она отгадывает, в худшем случае, за log2(N), где N - ширина интервала, совершает примерно столько же простейших вычислительных действий и вполне очевидно, что улучшить этот алгоритм невозможно. В некотором смысле, дальше мы весь наш разговор будем стремиться к тому, что написанно здесь в несколько строк. 

Поэтому, для начала, попробуем испортить нашу игру.

Что такое игра в угадайку? Два игрока договариваются о неком конечном множестве вариантов. 
В нашем случае, это целые числа от 1 до 100. 

Первый загадывает элемент множества. Второй игрок пытается отгадать загаданное, ставя гипотезу. Если второй игрок угадывает, игра считается оконченой победой второго игрока, если же нет, второй игрок получает некую подсказку, которая позволяет ему сузить число вариантов, необходимое для перебора.

В данном случае, алгоритм сужения очевидно сводится к сужению интервала. Но разберем другую всем известную версию игры в угадайку:

"Быки и коровы"

Играют двое.
Первый загадывает четырехзначное число без повторяющихся цифр.
Второй предлагает отгадку.
Если второй не угадал, первый сообщает второму число цифр, совпавших по позиции в загадке и отгадке ("быков"), а так же число цифр, присутствующих и в загадке и в отгадке, но не совпавших по позиции ("коров").


Известен оптимальный алгоритм, за авторством Дональда Кнута:

1) Построить множество S из всех возможных четырехзначных чисел без повторений.
2) Сделать следующий ход по правилу максимина:
    * Для любой комбинации из первоначальных (включая те, которых нет в S) вычислить, сколько возможных кодов будет удалено из S в случае любого результата хода. Количество очков начисляемое возможному ходу равно минимальному количеству элементов, которые можно будет удалить из S.
    * Из всех ходов с максимальным количеством очков предпочтение отдаётся тому ходу, который есть в S. Если таких вариантов несколько, то можно выбирать любой из них, например, с наименьшим значением.
    * Если наилучший ход не входит в S, то на следующем ходу игра точно не завершится.
3) Если комбинация угадана, алгоритм завершается.
4) Иначе, удалить из S все числа, которые будучи загаданными, дали бы результат, противоречащий полученному.
5) Повторить, начиная с пункта 2.

Чуть позже мы попробуем запрограммировать этот алгоритм, который назовем "максимин Кнута", а пока заметим следующее. Максимин Кнута оптимален не только для "быков и коров", но и для любой игры в угадайку вообще! Проиллюстрируем это наблюдение на нашей изначальной игре "от 1 до 100":

1) Множество S - множество всех чисел от 1 до 100
2) Для вычислений хода по правилу максимина, оценим, сколько вариантов мы отбросим при каждом из выборов. Вполне очевидно, что наше пространство вариантов всегда представляет некий интервал. При выборе числа из середины интервала (+-0.5) мы отбрасываем максимальное число вариантов.

Как видно, теоретически, максимин Кнута работает. Посмотрим на него в действии:

    from copy import deepcopy
    from functools import reduce

    def knut_maxmin(check, all_hiddens, results, cur_hiddens):
        return max(
            [(a,min(
                [sum(1 for _ in 
                    filter(lambda c: check(a, c) != r, 
                        deepcopy(cur_hiddens)),
                ) for r in results]
            )) for a in deepcopy(all_hiddens)], 
            key = lambda p: p[1] )[0]

Некоторые конструкции здесь могут быть непонятны. Прежде всего,
`sum(1 for _ in iter)` делает ровно то же самое, что и `len(list(iter))` но работает немного быстрее, так как не занимает память на развертку списка (попробуйте протестировать это, взяв `iter=range(1000000000)`). 

`deepcopy` нужен потому, что иначе cur_hiddens может истощиться за один прогон, как это бывает с итераторами. Остальное - "однострочная функциональная" реализация алгоритма максимина, когда каждое следующее значение передается выше и выше по цепочке вложенных функций - стиль, не очень удобный для чтения, но компактный и забавный. 

    def iter_game(all_hiddens, results, check, dialog, cur_hiddens):
        atempt = knut_maxmin(check, all_hiddens, results, cur_hiddens)

        result = dialog(atempt)
        if result is True:
            return atempt

        cur_hiddens = filter(
            lambda c: result == check(c, atempt),
            cur_hiddens
        )
        return iter_game(all_hiddens, results, check, dialog, cur_hiddens)


    if __name__ == '__main__':
        min_num = 1
        max_num = 100
        hiddens = range(min_num, max_num+1)
        results = ['>', '<']

        def check(hidden, answer):
            if hidden == answer:
                return True
            if hidden > answer:
                return '>'
            if hidden < answer:
                return '<'

        def dialog(atempt):
            res = input(f'Это {atempt}? ')
            if res == '=':
                return True
            if res in ('>','<'):
                return res
            print(
                '> если больше, = если равно, < если меньше \
                Попробуйте ещё раз'
            )
            return dialog(atempt)
        
        print(
            f'Игра "Угадай число"! \n\
            \nЗагадайте число от {min_num} до {max_num}, а я попробую угадать \
            \nВводите > если больше, = если равно, < если меньше\n'
        )

        x = iter_game(hiddens, results, check, dialog, hiddens)
        print(f'Ура, я угадал {x}!')

Запустив этот алгоритм, мы получим поведение, очень похожее на первый наш, оптимальный алгоритм. Но эй - во второй версии кода нет ничего наподобие `x = a + (b-a)//2` ! 

Что ещё лучше, наш алгоритм прекрасно работает и на "быки и коровы". Единственное, что нужно заменить - это передаваемые функции. 

    if __name__ == '__main__':
        length = 4
        hiddens = map(
            lambda comb: reduce(lambda x, y: x + y, comb),
            permutations('0123456789', length)
        )

        def check(hidden, answer):
            if hidden == answer:
                return True
            buf = len(list(
                filter(lambda l: l[0] == l[1], zip(hidden, answer))
            ))
            cow = len(hidden) + len(answer) - buf - len(set(hidden + answer))
            return buf, cow

        def dialog(atempt):
            res = input(f'{atempt}? ')
            try:
                res = tuple(map(int, res.split(' ')))
                assert len(res) == 2
                assert 0<=res[0]
                assert 0<=res[1]
                assert res[0]+res[1]<=length
            except (ValueError, AssertionError):
                print('Попробуйте ещё раз')
                return dialog(atempt)
            if res == (length,0):
                return True
            return res
        
        results = [(i, j) for i in range(length + 1) for j in range(length + 1 - i)]

        print(
            f'Игра "Быки и коровы"! \n\
            \nЗагадайте число, а я попробую угадать'
        )

        x = iter_game(hiddens, results, check, dialog, deepcopy(hiddens))
        print(f'Ура, я угадал {x}!')

И теперь мы сталкиваемся с другой проблемой. Наш алгоритм медленный.

Всю нашу историю мы будем наблюдать борьбу трех начал. 
1) Мы хотим построить универсальный алгоритм для любой игры в угадайку
2) Мы хотим, что бы наш алгоритм был оптмимальным, т.е решал задачу за минимальное или достаточно близкое к минимальному число попыток
3) Мы хотим, что бы наш алгоритм работал быстро

Наивная реализация "от 1 до 100" быстрая, оптимальная, но неуниверсальна
Максимин Кнута оптимален, универсален, но не быстр. Его затраты времени растут как N^2 от мощности множества вариантов. Это много! При length = 6 в настройке "быков и коров" N = 151200, и мы просто устанем ждать, пока комьютер просчитает все цепочки и придумает свой первый ход. 

К счастью, оказывается, стратегия максимина дает всего лишь самый лучший вариант. Если мы просто будем брать случайный элемент из пространства оставшихся возможных значений на каждом шаге, то, скорее всего, мы получим лишь немного худший результат, чем идеальная стратегия максимина. 

Проиллюстрируем это на примере "от 1 до 100"

В случае максимина мы на каждом шаге сокращаем пространство вариантов ровно в два раза. Если мы будем, вместо этого, выбирать случайный вариант на отрезке, и, в зависимости от, оставлять себе правую или левую сторону отрезка, то матожидание длины отрезка после сокращения будет:

интеграл(x^2 + (1-x)^2) = 2/3 от длины отрезка

То есть наша задача будет решаться в  ln(2)/ln(3/2) = 1.71 раз дольше. Это может показаться значительным падением качества решенной задачи, но, в действительности, задача всё ещё решается за log(N) ходов, что неплохо. Гораздо лучше, чем если бы мы просто перебирали варианты по порядку, не правда ли?

Время хаскеля!

Крутизна хаскеля в применении к нашей задаче проявится в том, что он позволяет очень строго формализовать все сущности, с которыми мы имеем дело.

...


Описываю реализацию на хаскеле. Показываю, что алгоритм случайного походящего работает гораздо быстрее максимина - тратит всего лишь O(n) на ход. Сравниваю алгоритмическую эффективность того и другого. При увеличении числа цифр алгорим всё равно получается медленным, так как очень долго перебирает числа в линии, прежде чем найдет подходящее под существующие условия.

Дело оказывается в структуре. Представьте, что вы услышали некое редкое слово русского языка и хотите уточнить его значение. У вас есть толковый словарь, но если бы вы не обращали внимание на структуру словаря (выраженную в том, что все слова упорядочены по алфавиту), поиск нужного слова посредством просмотра списка слов по порядку занял бы вечность. В нашей реализации генератор выплевывает вам все слова по порядку - не удивительно, что алгоритм теряет в эффективности.

Для некоторых игр подходящую структуру простроить очень легко. "Угадай число" позволяет вам просто запомнить наименьшее и наибольшее возможное число и искать ответ в означеном интервале.

"Поиск по словарю" требует от нас упорядочить все слова в словаре в виде дерева. 

Попробуем создать подходящую структуру под "быки и коровы". Для этого рассмотрим пространство над всем множеством ответов. У нас есть:

X - всё пространство ответов

X(1234 | 1,1) - подмножество X, для которого исполяется шаблон 1234 | 1,1 то есть 1 бык и одна корова в числе 1234

X(1234 | 1,1) && X(5678 | 0,2) - пересечение подможеств.

Нам нужен алгорим, который бы соотносил каждому непустому пересечению подмножество такого рода один из элементов этого подмножества или выдавал сообщение о пустоте.

Быки и коровы достаточно сложна, но на первую нам не обязательно оптимизировать всё. Частичная оптимизация уже может очень многое дать. Ограничим информацию, поступающую в отсекатель, суммой быков и коров в ответе. Ясно, что в таким раскладе все ответы становятся независимыми от перестановки цифр, но мы потом это поправим. Пока же мы можем выбрать вариант из шаблона:

X(1234 | 2) && X(5678 | 2) 

независимо от комбинации

и затем выбрать вариант с правильной перестановкой. 

Таким образом, мы уже существенно уменьшили задачу. Но этого не достаточно

Рассмотрим экстремальный вариант с 40-значным числом в 100-ричной системе счисления.

Всего чисел в такой системе 1e80, и мы не переберем их и за полвечности.

Число вариантов, ограниченных шаблоном X(***** | 20) составляет (40, 20)*(60, 20) 137846528820*4191844505805495 = 1e26 
Число вариантов по шаблону 

X(***** | 20) & X(***** | 20)



Допустим, X(1234 | 2). Выбрать 2 случайных от сюда и не от сюда.


В случае быков и коров X(1234 | 2) && X(3456 | 3)

12  34  56  7890 + (1356 | 2) = 
2   0   2   0
1   1   1   1
0   2   0   2


1   2   3   4   56  7890
1   0   0   1   1   1
0   1   1   0   1   1


(1457 | 2)




* Игры описание и реализация
    1) Игра "Угадай число"
    2) Игра "Быки и коровы"
    3) Подсказка в поисковике

* Анализ структуры игр - что их объединяет.
* Универсальные алгоритмы решения - глупейший рандом-алгоритм, максимин Кнута, умный рандом-алгоритм.

* Необходимость построения нелинейной структуры пространства решений. Древовидные структуры.
* структура пространства решений для подсказок в поисковике

Нужно как-нибудь закодировать это древо.


